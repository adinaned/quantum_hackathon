# -*- coding: utf-8 -*-
"""Copie a blocnotesului Quantum_Catan_Challenge_Quickstart.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xaOFIKVT70pwdgYY7dvkTI5FwzssRxFQ

# Quantum Catan Challenge ü™ôüè∞

In this notebook, you‚Äôll explore quantum optimization problems inspired by *Settlers of Catan*.

We‚Äôll begin with simple visualizations and setups for:
1. **Optimal Settlement Placement** ‚Äì evaluate resource yield on a small hex map.
2. **Longest Road Problem** ‚Äì find the longest continuous road under constraints.
3. **Resource Optimization** ‚Äì formulate a knapsack-style problem.

### Imports
"""

# --- Imports ---
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import random

"""## üè† Task 1 -- Optimal Quantum Settlement

### Task Description

In Catan, early settlement placement determines long-term success ‚Äî access to diverse resources, high-probability dice numbers, and potential expansion routes.

**Your goal:**
- Define an objective function that scores each possible **settlement vertex** (e.g., sum of dice probabilities weighted by resource diversity).
- Use a **quantum optimization algorithm** (like QAOA, VQE, or quantum annealing) to find the **best possible initial settlement placement**.

**You are provided:**
- A connected 7-hex Catan map (2‚Äì3‚Äì2 layout) with random terrains and dice numbers.  
- Each hex type corresponds to a resource (e.g., wood, brick, ore, wheat, sheep).  

**You may:**
- Assign weights for resource diversity, expected yield, or distance from other settlements.
- Encode the placement problem as a **combinatorial optimization** (e.g., a binary variable per node).  
- Compare results with a classical baseline (greedy, simulated annealing, etc.).  

üí° *Hint:* You can represent settlement choices as bitstrings and use a Hamiltonian of the form  
`H = Œ£_i w_i z_i + Œ£_{i,j} c_{ij} z_i z_j`  
for constraints like ‚Äúno two adjacent settlements.‚Äù

### Basic Map Generation
"""

import matplotlib.pyplot as plt
from matplotlib.patches import RegularPolygon
import numpy as np
import random

def draw_catan_terrain_map():
    # --- Parameters ---
    radius = 1.0  # hex side length
    hex_radius = radius

    # axial coordinates for the 7-hex (2‚Äì3‚Äì2) layout
    axial_coords = [(0, 0),
                    (1, 0), (1, -1), (0, -1),
                    (-1, 0), (-1, 1), (0, 1)]

    # convert axial to cartesian
    def axial_to_cart(q, r):
        x = hex_radius * (np.sqrt(3) * q + np.sqrt(3)/2 * r)
        y = hex_radius * (1.5 * r)
        return (x, y)

    hex_centers = [axial_to_cart(q, r) for q, r in axial_coords]

    # --- Random terrain + number assignment ---
    terrain_types = {
        "Forest": "#2E8B57",
        "Field": "#F4E04D",
        "Pasture": "#9ACD32",
        "Hill": "#D2691E",
        "Mountain": "#A9A9A9",
        # "Desert": "#EEDD82"
    }

    terrain_list = random.choices(list(terrain_types.keys()), k=len(hex_centers))
    dice_numbers = random.sample([2, 3, 4, 5, 6, 8, 9, 10, 11, 12], len(hex_centers))

    # --- Plot ---
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_aspect('equal')
    ax.axis('off')

    for (hx, hy), terrain, number in zip(hex_centers, terrain_list, dice_numbers):
        color = terrain_types[terrain]
        hex_patch = RegularPolygon(
            (hx, hy),
            numVertices=6,
            radius=hex_radius,
            orientation=np.radians(0),
            facecolor=color,
            alpha=1,
            edgecolor='k'
        )
        ax.add_patch(hex_patch)
        # Center text: dice number
        ax.text(hx, hy, str(number), ha='center', va='center',
                fontsize=16, fontweight='bold', color='black')
        # Terrain label
        ax.text(hx, hy - 0.6, terrain, ha='center', va='center',
                fontsize=9, color='black', alpha=0.7)

    ax.scatter(
        [hx for hx, hy in hex_centers],
        [hy for hx, hy in hex_centers],
        c=[terrain_types[t] for t in terrain_list],
        s=40,
        alpha=0
    )
    plt.title("Quantum Catan Challenge ‚Äî Random Terrain Map", fontsize=14)
    plt.show()

    return terrain_list, dice_numbers

# Run the generator
terrains, numbers = draw_catan_terrain_map()

"""## üõ£Ô∏è Task 2 -- Quantum Longest Road

### Task Description

The *Longest Road* in Catan is a classic path-finding and connectivity problem.  
Here, you‚Äôll use the connected road network graph of the 7-hex board.

**Your goal:**
- Identify the **longest continuous path** that could be built on the current network.
- Formulate the problem as a **graph traversal or combinatorial optimization** suitable for a quantum algorithm.

**Possible approaches:**
- Encode the pathfinding problem as a **QUBO** or **Ising Hamiltonian**, using penalty terms to ensure continuity.
- Use QAOA or a similar method to explore valid road configurations.
- Alternatively, use quantum random walks or amplitude amplification for path search.

üí° *Extension idea:* Consider randomizing blocked roads (representing occupied edges) and finding the new optimal route under constraints.

### Basic Map Generation
"""

import matplotlib.pyplot as plt
from matplotlib.patches import RegularPolygon
import numpy as np
import networkx as nx

def draw_connected_catan_board_aligned():
    # --- Parameters ---
    radius = 1.0  # hex side length
    hex_radius = radius
    # axial coordinates for 7-hex layout (center + 6 around)
    axial_coords = [(0, 0),
                    (1, 0), (1, -1), (0, -1),
                    (-1, 0), (-1, 1), (0, 1)]

    # convert axial to cartesian
    def axial_to_cart(q, r):
        x = hex_radius * (np.sqrt(3) * q + np.sqrt(3)/2 * r)
        y = hex_radius * (1.5 * r)
        return (x, y)

    hex_centers = [axial_to_cart(q, r) for q, r in axial_coords]

    # collect all vertices and edges
    vertices = []
    edges = []
    for (hx, hy) in hex_centers:
        for i in range(6):
            # rotate by +30¬∞ so that flat edges line up horizontally
            angle1 = np.radians(60 * i + 30)
            angle2 = np.radians(60 * (i + 1) + 30)
            x1, y1 = hx + hex_radius * np.cos(angle1), hy + hex_radius * np.sin(angle1)
            x2, y2 = hx + hex_radius * np.cos(angle2), hy + hex_radius * np.sin(angle2)
            vertices.append((x1, y1))
            vertices.append((x2, y2))
            edges.append(((x1, y1), (x2, y2)))

    # deduplicate nearby vertices
    unique_vertices = []
    tol = 1e-2
    def find_or_add(v):
        for u in unique_vertices:
            if np.linalg.norm(np.array(u) - np.array(v)) < tol:
                return u
        unique_vertices.append(v)
        return v

    merged_edges = []
    for a, b in edges:
        a2, b2 = find_or_add(a), find_or_add(b)
        if a2 != b2:
            merged_edges.append((a2, b2))

    # build graph
    G = nx.Graph()
    for v in unique_vertices:
        G.add_node(v)
    for a, b in merged_edges:
        G.add_edge(a, b)

    # plot
    fig, ax = plt.subplots(figsize=(8,8))
    ax.set_aspect('equal')
    ax.axis('off')

    # draw base hexes (rotated by 30¬∞)
    for (hx, hy) in hex_centers:
        hex_patch = RegularPolygon(
            (hx, hy),
            numVertices=6,
            radius=hex_radius,
            orientation=np.radians(0),
            facecolor='lightgray',
            alpha=0.2,
            edgecolor='k'
        )
        ax.add_patch(hex_patch)

    pos = {v: v for v in G.nodes()}
    nx.draw_networkx_edges(G, pos, ax=ax, width=2, edge_color='brown', alpha=0.8)
    nx.draw_networkx_nodes(G, pos, ax=ax, node_color='orange', node_size=60)

    plt.title("Connected and Aligned 7-Hex Catan Road Network", fontsize=14)
    plt.show()

    print(f"Total vertices (settlement points): {len(unique_vertices)}")
    print(f"Total edges (roads): {len(merged_edges)}")

draw_connected_catan_board_aligned()

"""## üåæ Task 3 -- Quantum Resource Optimization

### Task Description

Catan‚Äôs economy revolves around resource tradeoffs ‚Äî building requires specific combinations of resources that are produced with different probabilities.  
This can be viewed as a **quantum-enhanced knapsack** or **multi-objective allocation** problem.

**Your goal:**
- Model resource management as an optimization problem over a set of available resources and building costs.  
- Use quantum variational algorithms or sampling to find **optimal trading or building strategies** under uncertain dice outcomes.

**You can:**
- Simulate resource inflow based on dice probabilities and terrain layout.  
- Explore hybrid quantum-classical approaches (e.g., quantum sampling + classical linear optimization).  
- Extend the task creatively ‚Äî e.g., multi-turn planning or predicting expected returns for a player‚Äôs build plan.

**Example setup:**
- Resources: Wood, Brick, Wheat, Ore, Sheep
- Actions:
    - **Build Settlement**: 1 Wood, 1 Brick, 1 Wheat, 1 Sheep ‚Üí 1 Victory Point
    - **Build Road**: 1 Wood, 1 Brick ‚Üí 0.5 points
    - **Build City**: 2 Wheat, 3 Ore ‚Üí 2 points
- Each resource has an **expected production** based on dice numbers (simplified here for illustration).

You can encode this as:
- **Decision variables**: number of each action to take  
- **Constraints**: cannot spend more resources than you have  
- **Objective**: maximize total points

üí° *Hint:* Think of this as a *probabilistic resource knapsack*, where quantum superpositions could help explore multiple trade strategies at once.

### Example Problem Generation
"""

import pandas as pd

# Resources
resources = ["Wood", "Brick", "Wheat", "Ore", "Sheep"]

# Actions / costs
actions = {
    "Settlement": {"Wood":1,"Brick":1,"Wheat":1,"Sheep":1,"Points":1},
    "Road": {"Wood":1,"Brick":1,"Points":0.5},
    "City": {"Wheat":2,"Ore":3,"Points":2}
}

# Randomly generate resource production amounts for this "turn" or scenario
np.random.seed(42)
resource_availability = {res: np.random.randint(3,10) for res in resources}

# Convert actions to DataFrame for convenience
df_actions = pd.DataFrame(actions).T.fillna(0)
df_actions = df_actions[resources + ["Points"]]
df_actions["Points"] = df_actions["Points"].astype(float)

print("Available Resources:")
print(resource_availability)
print("\nActions Table:")
(df_actions)

"""## üß† Open Exploration

After completing the three tasks, teams are encouraged to:
- Combine sub-tasks into a single **‚ÄúQuantum Catan Agent‚Äù** capable of adaptive placement and expansion.
- Propose new quantum problem formulations or use hybrid architectures (QAOA + ML, reinforcement learning, etc.).
- Present visualizations, insights, or comparative analyses between quantum and classical solutions.

## Resources

If you‚Äôre new to quantum programming or need a quick refresher on qubits, superposition, and basic circuits, start with the [Hello World Quantum Computing](https://colab.research.google.com/github/mrvee-qC-bee/freeyamind-feb27/blob/main/1-2-Hello-World.ipynb) tutorial. It covers essential concepts to get your first quantum program running.

If your solution involves optimization on graphs ‚Äî for example, finding the best cut or partition ‚Äî check out the [QAOA Tutorial on MaxCut](https://colab.research.google.com/github/mrvee-qC-bee/freeyamind-feb27/blob/main/2-Quantum-Optimization-quantum-approximate-optimization-algorithm.ipynb), which demonstrates how the Quantum Approximate Optimization Algorithm can tackle discrete combinatorial problems.

If your problem deals with molecular structures or ground-state energy estimation, explore the [Variational Quantum Eigensolver (VQE)](https://quantum.cloud.ibm.com/learning/en/courses/quantum-chem-with-vqe/geometry) tutorial. It shows how hybrid quantum‚Äìclassical methods can compute molecular energies, serving as a bridge between chemistry and quantum optimization.

If your solution leans toward quantum-enhanced machine learning, the [Variational Quantum Classifier (VQC)](https://quantum.cloud.ibm.com/learning/en/courses/quantum-machine-learning/qvc-qnn) tutorial will guide you through building and training a simple quantum classifier using parameterized circuits and classical optimization.

Finally, check [IBM Quantum Learning](https://quantum.cloud.ibm.com/learning/en) for more resources, courses and tutorials.

## Qiskit Setup
"""

# !pip install qiskit
# !pip install qiskit_ibm_runtime
#
# pip install qiskit_aer

# imports
import numpy as np
from typing import List, Callable
from scipy.optimize import minimize
from scipy.optimize._optimize import OptimizeResult
import matplotlib.pyplot as plt

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector, Operator, SparsePauliOp
from qiskit.primitives import StatevectorSampler, PrimitiveJob
from qiskit.circuit.library import TwoLocal
from qiskit.visualization import plot_histogram
from qiskit_ibm_runtime.fake_provider import FakeSherbrooke
from qiskit_ibm_runtime import Session, EstimatorV2 as Estimator, SamplerV2 as Sampler
from qiskit_aer import AerSimulator
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

import qiskit_ibm_runtime
qiskit_ibm_runtime.__version__

def setup_qiskit_ibm_runtime():
    your_api_key = "recH341ke6E-hz6EiLNjTXy1XkwheUfp4C__nfhkZc8W"
    CRN = ""

    QiskitRuntimeService.save_account(
        channel="ibm_cloud",
        token=your_api_key,
        instance=CRN,
        name="hackathon",
        overwrite=True
    )

    service = QiskitRuntimeService(name="hackathon")
    return service

# you only need to run this once to set up the service
service = setup_qiskit_ibm_runtime()

# after setting up the service, you can just load it with:
service = QiskitRuntimeService(name="hackathon")

backend = service.least_busy(min_num_qubits=127)
print(backend)

pm = generate_preset_pass_manager(optimization_level=3, backend=backend)
sampler = Sampler(mode=backend)

qc = QuantumCircuit(5)
qc.h(0)
for i in range(4):
    qc.cx(i, i + 1)
qc.measure_all()
qc.draw(output='mpl')

transpiled_qc = pm.run(qc)
transpiled_qc.draw(output='mpl', idle_wires=False)

sampler.options.default_shots = 10000

# Set simple error suppression/mitigation options
sampler.options.dynamical_decoupling.enable = True
sampler.options.dynamical_decoupling.sequence_type = "XY4"
sampler.options.twirling.enable_gates = True
sampler.options.twirling.num_randomizations = "auto"

pub= (transpiled_qc, )
job = sampler.run([pub], shots=int(1e4))

job.status() # check job status -- when status is "DONE" you can retrieve the results

counts_sampler = job.result()[0].data.meas.get_counts()
print(len(counts_sampler))
plot_histogram(counts_sampler, title="Counts from Sampler", figsize=(10, 5))